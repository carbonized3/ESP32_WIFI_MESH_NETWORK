# MESH сеть на микроконтроллерах ESP32
Программный код данного проекта предназначен для построения `wifi-mesh сети` по древовидной или "chain" топологии на микроконтроллерах ESP32 для управления какими-либо исполнительными механизмами и телеметрии данных с любых датчиков. На каждом из микроконтроллеров может быть развернута своя встраиваемая система, которая будет являться частью сети, взаимодействующей с другими устройствами. В данной работе для разработки и отладки использовалось 4 устройства, на каждом их них было по одному реле, а в качестве телеметрии эмулировался датчик температуры.

## Содержание
- [MESH сеть на микроконтроллерах ESP32](#mesh-сеть-на-микроконтроллерах-esp32)
  - [Содержание](#содержание)
  - [Особенности](#особенности)
  - [Характеристики](#характеристики)
  - [Концепция](#концепция)
  - [Общая схема сети](#общая-схема-сети)
  - [Реализация удаленного доступа](#реализация-удаленного-доступа)
    - [1. Задача приёма по MQTT и отправка их участникам сети:](#1-задача-приёма-по-mqtt-и-отправка-их-участникам-сети)
    - [2. Задача приёма данных внутри сети:](#2-задача-приёма-данных-внутри-сети)
  - [Реализация телеметрии](#реализация-телеметрии)
    - [1. Задача отправки данных MQTT:](#1-задача-отправки-данных-mqtt)
    - [2. Задача отправки данных брокеру MQTT:](#2-задача-отправки-данных-брокеру-mqtt)
  - [Заключение](#заключение)
___
## Особенности
- Код почти универсален для всех узлов в сети. Чтобы перенести его на новое устройство, нужно лишь добавить задачи для работы с конкретными устройствами, обеспечить их взаимодействия с основными функциями и поправить небольшое количество строк. Более подробно в комментариях исходного файла `mesh_main.c`.

- Реализован удаленный доступ к каждому узлу в сети посредством протокола MQTT и отечественного бесплатного брокера clusterfly.ru.

- Реализована телеметрия также через MQTT.
____

## Характеристики
Производительность сети ESP-WIFI-MESH оценивалась самим разработчиками ESP-IDF на основе показателей:

- `Время построения сети:` количество времени, затраченное на создание сети ESP-WIFI-MESH с нуля. 
  - **`< 60 seconds`**
- `Время восстановления:` количество времени, которое требуется сети для обнаружения отказа узла и выполнения соответствующих действий для восстановления сети (например, создание избрание нового корневого узла или формирование новых соединений)
  - От отказа корневого узла: **`< 10 seconds`**
  - От отказа потомственного узла: **`< 5 seconds`**
- `Задержка на переход (Per-hop latency):` задержка передачи данных по одному беспроводному переходу. Другими словами, время, необходимое для передачи пакета данных от родительского узла к дочернему узлу или наоборот
  - **`от 10 до 30 мс`**
- `Емкость сетевого узла:` общее количество узлов, которые сеть ESP-WIFI-MESH может поддерживать одновременно. Это число определяется максимальным количеством нисходящих подключений, которые может принять узел, и максимальным количеством уровней, допустимых в сети
  - **`100`**

___
## Концепция
Для взаимодействия между микроконтроллерами ESP32 используется протокол **ESP-WIFI-MESH**, входящий в состав API `esp_mesh`, который и реализует построение mesh сети по древовидной топологии. Программно назначенных ролей в сети нет, все определяется исходя из взаимного расположения участников сети динамически. Данный протокол также обеспечивает **автоматическое построение сети** и **самовосстановление от отказа узлов**. В данной сети всегда только одно устройство (корневое) подключается к маршрутизатору и имеет прямой доступ во внешнюю IP сеть.

Вся программа написана на языке `С` с помощью родного для ESP32 комплекта `ESP-IDF`, который использует операционную систему реального времени `FreeRTOS`. Разработка велась в `VSCode` и расширения `Platformio`. 

Для управления и телеметрии используется MQTT брокер [clusterfly.ru](https://clusterfly.ru/). 

![Dashboard брокера clusterfly](https://i.postimg.cc/JnPpRwvy/clusterfly-ru-Dashboard.jpgy,  "Dashboard брокера clusterfly")


Программный код, как уже было сказано, почти универсальный. На разных микроконтроллерах сети работают одни и те же задачи. Отличие работы кода на разных устройствах в том, что, во-первых, на корневом узле запускаются ещё 2 дополнительные задачи для работы с внешней IP сетью (с брокером MQTT), во-вторых, в теле бесконечных циклов задач имеются ветвления, которые и позволяют использовать одну и ту же задачу для каждого узла:

```C
if(esp_mesh_is_root())  /*  Устройство знает, корневое оно или нет  */
{
  ... 
}
else 
{ 
  ...
}     
```

Очередность выполнения тех или иных действий при возникновении событий в данной mesh сети (подключения к маршрутизатору, подключение/отключения потомков и т.д.) возможно благодаря обработчику событий `mesh_event_handler`, который мы сами создаем и регестрируем функцией, встроенной в API. Его входны аргументы должны быть стандартного вида:

```C
void mesh_event_handler(void *arg, esp_event_base_t event_base,
                        int32_t event_id, void *event_data)
{
    switch (event_id) {
    case MESH_EVENT_PARENT_CONNECTED: 
      ... /*  Код обработки события  */
      break;
    ...
    case MESH_EVENT_CHILD_DISCONNECTED:
      ...
      break;
    ...
    }
}
```
___
## Общая схема сети

 ![Общая схема сети](https://i.postimg.cc/c1BBm1T4/image.png,  "")

Естественно, устройства могут быть расположены в пространстве и по-другому, это роли не играет - каждый из них может быть как корневым узлом, так и промежуточным родительским или конечным.

___
## Реализация удаленного доступа

![Удаленный доступ](https://i.postimg.cc/Jn4zCqwF/image.png,  "Удаленный доступ")

Управляющие сообщения от брокера доставляются устройствам широковещательными пакетами, т.е корневой узел, получив по MQTT сообщение, рассылает его всем участникам сети. Если пакет предназначен самому корневому узлу, то он не делает рассылку, а обрабатывает его сам. На приёмной стороне устройства сами определяют, нужно ли им обрабатывать данный пакет или нет. Все узлы сети, получающие сообщения, обрабатывают его посредством парсинга принятого сообщения (строки) на предмет известной им строки с топиком.

### 1. Задача приёма по MQTT и отправка их участникам сети:

Если микроконтроллер является корневым, то на нём выполняется задача с длинным, но говорящим названием: `esp_mesh_rx_from_mqtt_and_tx_to_all_nodes`. Её суть сводится к отправке полученных по MQTT сообщений всем участникам сети. Задача создается только на корневом устройстве, так как только оно может получать напрямую данные по MQTT.

Далее идѐт основная часть задачи, в которой задача бесконечно ожидает поступления данных в очередь `mqtt_queue_rx` в блокированном состоянии:

```C
void esp_mesh_rx_from_mqtt_and_tx_to_all_nodes(void *arg)
{
  ...
  while (is_running)
  {
    xQueueReceive(mqtt_queue_rx, &payload, portMAX_DELAY);    
    esp_mesh_get_routing_table((mesh_addr_t *) &route_table
    CONFIG_MESH_ROUTE_TABLE_SIZE * 6, &route_table_size);    
    /* Получили размер таблицы маршрутизации сети */
    snprintf(str, sizeof(str), "%s/%s", payload.str_topic, payload.str_data);
    /*  Объединяем два поля в одну строку для передачи в формате topic/data     */
    data.data = (uint8_t *)str;     

```
До того, как разослать сообщение узлам, МК проверяет, не ему ли пришла команда. Если да, то он отдаёт семафор задаче по работе с исполнительным механизмом (реле) и пропускает текущую итерацию цикла.

```C
    if( strcmp((char *)data.data, "user_f8c55df1/relayA/0") == 0)   /* Если запрос пришёл на самого себя на выключение реле корневой ноды */
    {
      relay_on_or_off = RELAY_OFF;
      xSemaphoreGive(relay_semaphore);
      continue;
    }
    else if ( strcmp((char *)data.data, "user_f8c55df1/relayA/1") == 0) /* Если запрос пришёл на самого себя на включение реле корневой ноды */
    {
      relay_on_or_off = RELAY_ON;
      xSemaphoreGive(relay_semaphore);
      continue;
    }
```

После этого происходит процесс передачи пакета с сообщением всем участникам сети, если пропуска итерации цикла не случилось.

```C     
    for (int i = 0; i < route_table_size; i++) 
    {
      snprintf(mac_str, sizeof(mac_str) , MACSTR,
      route_table[i].addr[0], route_table[i].addr[1], route_table[i].addr[2], route_table[i].addr[3], route_table[i].addr[4], route_table[i].addr[5]
      );
      if( strcmp(mac_str, NODE_A_STA_MAC_STR) == 0)
      {
        continue;
      }   
      err = esp_mesh_send(&route_table[i], &data, MESH_DATA_P2P, NULL, 0);   
    }
  }
    ...
}
```
Ожидаются данные из обработчика событий MQTT, который мы создаем, а затем регестрируем также с помощью функций API. Там же выставляется бит установки соединения с брокером MQTT:

```C
static void mqtt_event_handler(void *handler_args, esp_event_base_t base, int32_t event_id, void *event_data)
{
  ...
  switch ((esp_mqtt_event_id_t)event_id) 
  {    
    case MQTT_EVENT_CONNECTED:
      ...
      xEventGroupSetBits(mqtt_state_event_group, MQTT_EVT_CONNECTED);
      break;
    ...
    case MQTT_EVENT_DATA:
      snprintf(payload.str_topic, sizeof(payload.str_topic), "%.*s", event->topic_len, event->topic); 
      snprintf(payload.str_data, sizeof(payload.str_data), "%.*s", event->data_len, event->data); 
      /*  Завернули в нашу структуру входные данные */
      xQueueSendToBack(mqtt_queue_rx, &payload, 0); 
      break;
    ...
  }
}
```
### 2. Задача приёма данных внутри сети:

Далее, все устройства, кроме корневого должны как-то принять и обработать пакет, который им отправлен корневым узлом. Этим занимается задача `esp_mesh_rx_from_nodes`. В начале, до бесконечного цикла идѐт инициализация всех необходимых переменных, структур. Если данный микроконтроллер стал корневым узлом сети, то он ожидает установки бита подключения к MQTT брокеру, и на каждом цикле проверяет этот бит и НЕ очищает его. Только если есть соединение с MQTT брокером наш узел может принимать пакеты от других участников сети. 
```C
void esp_mesh_rx_from_nodes(void *arg)
{
  ...
  mesh_data_t data;     /* Структура библиотеки esp_wifi_mesh  */
  const uint8_t STR_SIZE = STR_TOPIC_SIZE + STR_DATA_SIZE + 1;
  char str[STR_SIZE];          
  char str_topic[STR_TOPIC_SIZE];
  char str_data[STR_DATA_SIZE];
  ...
  while (is_running) {
    if(esp_mesh_is_root())
    {
      EventBits_t bits = xEventGroupWaitBits(mqtt_state_event_group
      MQTT_EVT_CONNECTED, pdFALSE, pdTRUE, portMAX_DELAY);
      /* Ждѐм бита подключения mqtt */
      ...
      err = esp_mesh_recv(&from, &data, portMAX_DELAY, &flag, NULL, 0);
      /*  Принимаем пакет в data  */
      buff = (char *)data.data;

```
Принятые пакеты с сообщениями разбиваются на `топик` и полезную информацию `(data)`. Для этого используется смещение на величину известного префикса (требование брокера), с которого начинаются любые сообщения. Микроконтроллер зная, что ему передаются цифры (например температура), записывает в массив `str_topic` символ за символом, получая строку с топиком. 

```C
      strcpy(str_topic, "user_f8c55df1/");
      /* Доабвим заранее известный префикс  */
      i = strlen(str_topic);
      while (i < str_size)
      {
        if(buff[i+1] >= ASCII_0 && buff[i+1] <= ASCII_9) 
        {
          str_topic[i] = '\0';
          i++;
          break;
        }
        str_topic[i] = buff[i];
        i++;
      }
      ...
      j = 0;
```
Оставшиеся символы будут являться полезной информацией, которая заносится в массив полезных данных `str_data`.
```C
      while (buff[i] != '\0')
      {
        str_data[j] = buff[i];
        i++;
        j++;
      }
      str_data[j] = '\0';
      ...
```
Затем сообщение передается посредством очереди задаче, которая отправит это сообщение брокеру MQTT:
```C
    xQueueSendToBack(mqtt_queue_tx, &payload, 500 / portTICK_RATE_MS);
    }
}
```
___


## Реализация телеметрии

 ![Реализация телеметрии](https://i.postimg.cc/C1Nnj503/image.png,  "")

Каждое устройство отправляет полезные данные MQTT брокеру посредством передачи пакетов корневому узлу, а тот в свою очередь обрабатывает их и отправляет брокеру.

### 1. Задача отправки данных MQTT:

Реализует телеметрию задача передачи данных `esp_mesh_p2p_tx_main`.
Функционал этой задачи сводится к тому, что если узел является корневым, то он отправляет полезные данные (температуру) напрямую в другую задачу для передачи их по MQTT, а если не является, то отправляет данные корневому устройству. В начале происходит инициализация нужных переменных и структур, в частности переменная `payload` структуры `mqttPayload`. 

```C
typedef struct {            
    char str_topic[40];
    char str_data[40];
} mqttPayload;
...
void esp_mesh_p2p_tx_main(void *arg)
{
    ...
    mesh_data_t data;     /* Структура библиотеки esp_wifi_mesh  */
    mqttPayload payload;
    char *str_topic = "user_f8c55df1/tempA";
    ...
    while (is_running) {    
      if(esp_mesh_is_root())
      {
        EventBits_t bits = xEventGroupWaitBits(mqtt_state_event_group,  
        MQTT_EVT_CONNECTED, pdFALSE, pdTRUE, portMAX_DELAY);
        /* Ждѐм бита подключения mqtt */ 
        ...
        snprintf(payload.str_topic, sizeof(payload.str_topic), str_topic);  
        printf("payload.str_topic is: %s\n", payload.str_topic);  
        itoa(temperature, str_data, 10);
        /*  Завернули температуру в строку и поместили её в str_data  */   
        snprintf(payload.str_data, sizeof(payload.str_data), str_data);  
        /*  Затем завернули в поле структруы  */
        printf("payload.str_data is: %s\n", payload.str_data);
        xQueueSendToBack(mqtt_queue_tx, &payload, portMAX_DELAY);
        /* И отправили объект структуры задаче по работе с MQTT   */        
        vTaskDelay(2000 / portTICK_RATE_MS);                              
      }

```
Если узел не является корневым, то он также преобразует полезные данные и топик в строку. Делается конкатенация этих строк и, на получившуюся новую строку, присваивается указатель полю структуры `mesh_data_t`, с помощью которой пакет передаѐтся корневому узлу:
```C
      else 
      {
        ...
            itoa(temperature, str_data, 10);    
            snprintf(str_to_mqtt, sizeof(str_to_mqtt), "%s/%s", str_topic, str_data);
            data.data = (uint8_t *)str_to_mqtt;     
            err = esp_mesh_send(NULL, &data, MESH_DATA_TODS, NULL, 0);
            /*  Первый аргумент NULL - значит отправка корневому узлу  */  
            ...
        }
```
### 2. Задача отправки данных брокеру MQTT: 

Передача данных по MQTT брокеру происходит в задаче `esp_mesh_tx_to_mqtt`. Задача ожидает поступления в неё бесконечно долго до тех пор, пока в ней что-нибудь не появится. В конце цикла делается задержка – это связано с ограничением самого брокера на период публикаций.
```C
void esp_mesh_tx_to_mqtt(void *arg)
{
  mqttPayload msg;
  ...
  while (is_running)
  {
    xQueueReceive(mqtt_queue_tx, &msg, portMAX_DELAY);
    ...
    msg_id = esp_mqtt_client_publish(client, msg.str_topic, msg.str_data, 0, 1, 0);
    /*  Публикация сообщения  */
    vTaskDelay(1200 / portTICK_RATE_MS);    
  }
}
```
**Задача для работы с реле элементарная и здесь не описывается.**
___
## Заключение
Данный проект являлся моей выпускной работой и на данном этапе активно дорабатывается. В коде отсутсвуют задачи для работы с какими-либо датчиками, так как была конкретная задача организовать mesh сеть и реализовать в ней телеметрию и удаленный доступ. В случае необходимости использовать какие-либо датчики или исполнительные механизмы, функции и задачи по работе с ними достаточно легко интегрировать в существующую программную основу за счёт использования FreeRTOS. Нужно будет лишь в местах, где происходит эмуляция процесса, вставлять вызовы реальных функций.


